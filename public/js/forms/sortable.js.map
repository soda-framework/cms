{"version":3,"sources":["jquery.nested-sortable.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"sortable.js","sourcesContent":["/*\n * jQuery UI Nested Sortable\n * v2.1.0 / 2016-06-21\n * https://github.com/QueenCityCodeFactory/nested-sortable\n *\n * Depends on:\n *   jquery.ui.sortable.js 1.10+\n *\n * Copyright (c) 2010-2016 Manuele J Sarfatti and contributors\n * Licensed under the MIT License\n * http://www.opensource.org/licenses/mit-license.php\n */\n(function( factory ) {\n    \"use strict\";\n\n    if ( typeof define === \"function\" && define.amd ) {\n        // AMD. Register as an anonymous module.\n        define([\n            \"jquery\",\n            \"jquery-ui/sortable\"\n        ], factory );\n    } else {\n        // Browser globals\n        factory( window.jQuery );\n    }\n}(function($) {\n    \"use strict\";\n\n    function isOverAxis( x, reference, size ) {\n        return ( x > reference ) && ( x < ( reference + size ) );\n    }\n\n    $.widget(\"qccf.nestedSortable\", $.extend({}, $.ui.sortable.prototype, {\n\n        options: {\n            disableParentChange: false,\n            doNotClear: false,\n            expandOnHover: 700,\n            isAllowed: function() { return true; },\n            isTree: false,\n            listType: \"ol\",\n            maxLevels: 0,\n            protectRoot: false,\n            rootID: null,\n            rtl: false,\n            startCollapsed: false,\n            tabSize: 20,\n            excludeRoot: false,\n            left: \"lft\",\n            right: \"rght\",\n            attribute: \"id\",\n\n            branchClass: \"nested-sortable-branch\",\n            collapsedClass: \"nested-sortable-collapsed\",\n            disableNestingClass: \"nested-sortable-no-nesting\",\n            errorClass: \"nested-sortable-error\",\n            expandedClass: \"nested-sortable-expanded\",\n            hoveringClass: \"nested-sortable-hovering\",\n            leafClass: \"nested-sortable-leaf\",\n            disabledClass: \"nested-sortable-disabled\"\n        },\n\n        _create: function() {\n            var self = this;\n            var err;\n\n            this.element.data(\"ui-sortable\", this.element.data(\"qccf.nestedSortable\"));\n\n            // prevent browser from freezing if the HTML is not correct\n            if (!this.element.is(this.options.listType)) {\n                err = \"NestedSortable: Please check that the listType option is set to your actual list type.\";\n\n                throw new Error(err);\n            }\n\n            // if we have a tree with expanding/collapsing functionality,\n            // force 'intersect' tolerance method\n            if (this.options.isTree && this.options.expandOnHover) {\n                this.options.tolerance = \"intersect\";\n            }\n\n            $.ui.sortable.prototype._create.apply(this, arguments);\n\n            // prepare the tree by applying the right classes\n            // (the CSS is responsible for actual hide/show functionality)\n            if (this.options.isTree) {\n                $(this.items).each(function() {\n                    var $li = this.item;\n                    var hasCollapsedClass = $li.hasClass(self.options.collapsedClass);\n                    var hasExpandedClass = $li.hasClass(self.options.expandedClass);\n\n                    if ($li.children(self.options.listType).length) {\n                        $li.addClass(self.options.branchClass);\n                        // expand/collapse class only if they have children\n\n                        if ( !hasCollapsedClass && !hasExpandedClass ) {\n                            if (self.options.startCollapsed) {\n                                $li.addClass(self.options.collapsedClass);\n                            } else {\n                                $li.addClass(self.options.expandedClass);\n                            }\n                        }\n                    } else {\n                        $li.addClass(self.options.leafClass);\n                    }\n                });\n            }\n        },\n\n        _destroy: function() {\n            this.element\n                .removeData(\"qccf.nestedSortable\")\n                .removeData(\"ui-sortable\");\n            return $.ui.sortable.prototype._destroy.apply(this, arguments);\n        },\n\n        _mouseDrag: function(event) {\n            var i;\n            var item;\n            var itemElement;\n            var intersection;\n            var self = this;\n            var o = this.options;\n            var scrolled = false;\n            var $document = $(document);\n            var previousTopOffset;\n            var parentItem;\n            var level;\n            var childLevels;\n            var itemAfter;\n            var itemBefore;\n            var newList;\n            var method;\n            var a;\n            var previousItem;\n            var nextItem;\n            var helperIsNotSibling;\n\n            //Compute the helpers position\n            this.position = this._generatePosition(event);\n            this.positionAbs = this._convertPositionTo(\"absolute\");\n\n            if (!this.lastPositionAbs) {\n                this.lastPositionAbs = this.positionAbs;\n            }\n\n            //Do scrolling\n            if (this.options.scroll) {\n                if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== \"HTML\") {\n                    if (\n                        (\n                            this.overflowOffset.top +\n                            this.scrollParent[0].offsetHeight\n                        ) -\n                        event.pageY <\n                        o.scrollSensitivity\n                    ) {\n                        scrolled = this.scrollParent.scrollTop() + o.scrollSpeed;\n                        this.scrollParent.scrollTop(scrolled);\n                    } else if (\n                        event.pageY -\n                        this.overflowOffset.top <\n                        o.scrollSensitivity\n                    ) {\n                        scrolled = this.scrollParent.scrollTop() - o.scrollSpeed;\n                        this.scrollParent.scrollTop(scrolled);\n                    }\n\n                    if (\n                        (\n                            this.overflowOffset.left +\n                            this.scrollParent[0].offsetWidth\n                        ) -\n                        event.pageX <\n                        o.scrollSensitivity\n                    ) {\n                        scrolled = this.scrollParent.scrollLeft() + o.scrollSpeed;\n                        this.scrollParent.scrollLeft(scrolled);\n                    } else if (\n                        event.pageX -\n                        this.overflowOffset.left <\n                        o.scrollSensitivity\n                    ) {\n                        scrolled = this.scrollParent.scrollLeft() - o.scrollSpeed;\n                        this.scrollParent.scrollLeft(scrolled);\n                    }\n\n                } else {\n\n                    if (\n                        event.pageY -\n                        $document.scrollTop() <\n                        o.scrollSensitivity\n                    ) {\n                        scrolled = $document.scrollTop() - o.scrollSpeed;\n                        $document.scrollTop(scrolled);\n                    } else if (\n                        $(window).height() -\n                        (\n                            event.pageY -\n                            $document.scrollTop()\n                        ) <\n                        o.scrollSensitivity\n                    ) {\n                        scrolled = $document.scrollTop() + o.scrollSpeed;\n                        $document.scrollTop(scrolled);\n                    }\n\n                    if (\n                        event.pageX -\n                        $document.scrollLeft() <\n                        o.scrollSensitivity\n                    ) {\n                        scrolled = $document.scrollLeft() - o.scrollSpeed;\n                        $document.scrollLeft(scrolled);\n                    } else if (\n                        $(window).width() -\n                        (\n                            event.pageX -\n                            $document.scrollLeft()\n                        ) <\n                        o.scrollSensitivity\n                    ) {\n                        scrolled = $document.scrollLeft() + o.scrollSpeed;\n                        $document.scrollLeft(scrolled);\n                    }\n\n                }\n\n                if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\n                    $.ui.ddmanager.prepareOffsets(this, event);\n                }\n            }\n\n            //Regenerate the absolute position used for position checks\n            this.positionAbs = this._convertPositionTo(\"absolute\");\n\n            // find the top offset before rearrangement,\n            previousTopOffset = this.placeholder.offset().top;\n\n            //Set the helper position\n            if (!this.options.axis || this.options.axis !== \"y\") {\n                this.helper[0].style.left = this.position.left + \"px\";\n            }\n            if (!this.options.axis || this.options.axis !== \"x\") {\n                this.helper[0].style.top = (this.position.top) + \"px\";\n            }\n\n            // check and reset hovering state at each cycle\n            this.hovering = this.hovering ? this.hovering : null;\n            this.mouseentered = this.mouseentered ? this.mouseentered : false;\n\n            // let's start caching some variables\n            (function() {\n                var _parentItem = this.placeholder.parent().parent();\n                if (_parentItem && _parentItem.closest(\".ui-sortable\").length) {\n                    parentItem = _parentItem;\n                }\n            }.call(this));\n\n            level = this._getLevel(this.placeholder);\n            childLevels = this._getChildLevels(this.helper);\n            newList = document.createElement(o.listType);\n\n            //Rearrange\n            for (i = this.items.length - 1; i >= 0; i--) {\n\n                //Cache variables and intersection, continue if no intersection\n                item = this.items[i];\n                itemElement = item.item[0];\n                intersection = this._intersectsWithPointer(item);\n                if (!intersection) {\n                    continue;\n                }\n\n                // Only put the placeholder inside the current Container, skip all\n                // items form other containers. This works because when moving\n                // an item from one container to another the\n                // currentContainer is switched before the placeholder is moved.\n                //\n                // Without this moving items in \"sub-sortables\" can cause the placeholder to jitter\n                // between the outer and inner container.\n                if (item.instance !== this.currentContainer) {\n                    continue;\n                }\n\n                // No action if intersected item is disabled\n                // and the element above or below in the direction we're going is also disabled\n                if (itemElement.className.indexOf(o.disabledClass) !== -1) {\n                    // Note: intersection hardcoded direction values from\n                    // jquery.ui.sortable.js:_intersectsWithPointer\n                    if (intersection === 2) {\n                        // Going down\n                        itemAfter = this.items[i + 1];\n                        if (itemAfter && itemAfter.item.hasClass(o.disabledClass)) {\n                            continue;\n                        }\n\n                    } else if (intersection === 1) {\n                        // Going up\n                        itemBefore = this.items[i - 1];\n                        if (itemBefore && itemBefore.item.hasClass(o.disabledClass)) {\n                            continue;\n                        }\n                    }\n                }\n\n                method = intersection === 1 ? \"next\" : \"prev\";\n\n                // cannot intersect with itself\n                // no useless actions that have been done before\n                // no action if the item moved is the parent of the item checked\n                if (itemElement !== this.currentItem[0] &&\n                    this.placeholder[method]()[0] !== itemElement &&\n                    !$.contains(this.placeholder[0], itemElement) &&\n                    (\n                        this.options.type === \"semi-dynamic\" ?\n                            !$.contains(this.element[0], itemElement) :\n                            true\n                    )\n                ) {\n\n                    // we are intersecting an element:\n                    // trigger the mouseenter event and store this state\n                    if (!this.mouseentered) {\n                        $(itemElement).mouseenter();\n                        this.mouseentered = true;\n                    }\n\n                    // if the element has children and they are hidden,\n                    // show them after a delay (CSS responsible)\n                    if (o.isTree && $(itemElement).hasClass(o.collapsedClass) && o.expandOnHover) {\n                        if (!this.hovering) {\n                            $(itemElement).addClass(o.hoveringClass);\n                            this.hovering = window.setTimeout(function() {\n                                $(itemElement)\n                                    .removeClass(o.collapsedClass)\n                                    .addClass(o.expandedClass);\n\n                                self.refreshPositions();\n                                self._trigger(\"expand\", event, self._uiHash());\n                            }, o.expandOnHover);\n                        }\n                    }\n\n                    this.direction = intersection === 1 ? \"down\" : \"up\";\n\n                    // rearrange the elements and reset timeouts and hovering state\n                    if (this.options.tolerance === \"pointer\" || this._intersectsWithSides(item)) {\n                        $(itemElement).mouseleave();\n                        this.mouseentered = false;\n                        $(itemElement).removeClass(o.hoveringClass);\n                        if (this.hovering) {\n                            window.clearTimeout(this.hovering);\n                        }\n                        this.hovering = null;\n\n                        // do not switch container if\n                        // it's a root item and 'protectRoot' is true\n                        // or if it's not a root item but we are trying to make it root\n                        if (o.protectRoot &&\n                            !(\n                                this.currentItem[0].parentNode === this.element[0] &&\n                                // it's a root item\n                                itemElement.parentNode !== this.element[0]\n                                // it's intersecting a non-root item\n                            )\n                        ) {\n                            if (this.currentItem[0].parentNode !== this.element[0] &&\n                                itemElement.parentNode === this.element[0]\n                            ) {\n\n                                if ( !$(itemElement).children(o.listType).length) {\n                                    itemElement.appendChild(newList);\n                                    if (o.isTree) {\n                                        $(itemElement)\n                                            .removeClass(o.leafClass)\n                                            .addClass(o.branchClass + \" \" + o.expandedClass);\n                                    }\n                                }\n\n                                if (this.direction === \"down\") {\n                                    a = $(itemElement).prev().children(o.listType);\n                                } else {\n                                    a = $(itemElement).children(o.listType);\n                                }\n\n                                if (a[0] !== undefined) {\n                                    this._rearrange(event, null, a);\n                                }\n\n                            } else {\n                                this._rearrange(event, item);\n                            }\n                        } else if (!o.protectRoot) {\n                            this._rearrange(event, item);\n                        }\n                    } else {\n                        break;\n                    }\n\n                    // Clear emtpy ul's/ol's\n                    this._clearEmpty(itemElement);\n\n                    this._trigger(\"change\", event, this._uiHash());\n                    break;\n                }\n            }\n\n            // to find the previous sibling in the list,\n            // keep backtracking until we hit a valid list item.\n            (function() {\n                var _previousItem = this.placeholder.prev();\n                if (_previousItem.length) {\n                    previousItem = _previousItem;\n                } else {\n                    previousItem = null;\n                }\n            }.call(this));\n\n            if (previousItem !== null && previousItem !== undefined) {\n                while (\n                    previousItem[0].nodeName.toLowerCase() !== \"li\" ||\n                    previousItem[0].className.indexOf(o.disabledClass) !== -1 ||\n                    previousItem[0] === this.currentItem[0] ||\n                    previousItem[0] === this.helper[0]\n                ) {\n                    if (previousItem[0].previousSibling) {\n                        previousItem = $(previousItem[0].previousSibling);\n                    } else {\n                        previousItem = null;\n                        break;\n                    }\n                }\n            }\n\n            // to find the next sibling in the list,\n            // keep stepping forward until we hit a valid list item.\n            (function() {\n                var _nextItem = this.placeholder.next();\n                if (_nextItem.length) {\n                    nextItem = _nextItem;\n                } else {\n                    nextItem = null;\n                }\n            }.call(this));\n\n            if (nextItem !== null && nextItem !== undefined) {\n                while (\n                    nextItem[0].nodeName.toLowerCase() !== \"li\" ||\n                    nextItem[0].className.indexOf(o.disabledClass) !== -1 ||\n                    nextItem[0] === this.currentItem[0] ||\n                    nextItem[0] === this.helper[0]\n                ) {\n                    if (nextItem[0].nextSibling) {\n                        nextItem = $(nextItem[0].nextSibling);\n                    } else {\n                        nextItem = null;\n                        break;\n                    }\n                }\n            }\n\n            this.beyondMaxLevels = 0;\n\n            // if the item is moved to the left, send it one level up\n            // but only if it's at the bottom of the list\n            if (parentItem !== null &&\n                parentItem !== undefined &&\n                (nextItem === null || nextItem === undefined) &&\n                !(o.protectRoot && parentItem[0].parentNode == this.element[0]) &&\n                (\n                    o.rtl &&\n                    (\n                        this.positionAbs.left +\n                        this.helper.outerWidth() > parentItem.offset().left +\n                        parentItem.outerWidth()\n                    ) ||\n                    !o.rtl && (this.positionAbs.left < parentItem.offset().left)\n                )\n            ) {\n\n                parentItem.after(this.placeholder[0]);\n                helperIsNotSibling = !parentItem\n                    .children(o.listItem)\n                    .children(\"li:visible:not(.ui-sortable-helper)\")\n                    .length;\n                if (o.isTree && helperIsNotSibling) {\n                    parentItem\n                        .removeClass(this.options.branchClass + \" \" + this.options.expandedClass)\n                        .addClass(this.options.leafClass);\n                }\n                if(typeof parentItem !== 'undefined')\n                    this._clearEmpty(parentItem[0]);\n                this._trigger(\"change\", event, this._uiHash());\n                // if the item is below a sibling and is moved to the right,\n                // make it a child of that sibling\n            } else if (previousItem !== null && previousItem !== undefined &&\n                !previousItem.hasClass(o.disableNestingClass) &&\n                (\n                    previousItem.children(o.listType).length &&\n                    previousItem.children(o.listType).is(\":visible\") ||\n                    !previousItem.children(o.listType).length\n                ) &&\n                !(o.protectRoot && this.currentItem[0].parentNode === this.element[0]) &&\n                (\n                    o.rtl &&\n                    (\n                        this.positionAbs.left +\n                        this.helper.outerWidth() <\n                        previousItem.offset().left +\n                        previousItem.outerWidth() -\n                        o.tabSize\n                    ) ||\n                    !o.rtl &&\n                    (this.positionAbs.left > previousItem.offset().left + o.tabSize)\n                )\n            ) {\n\n                this._isAllowed(previousItem, level, level + childLevels + 1);\n\n                if (!previousItem.children(o.listType).length) {\n                    previousItem[0].appendChild(newList);\n                    if (o.isTree) {\n                        previousItem\n                            .removeClass(o.leafClass)\n                            .addClass(o.branchClass + \" \" + o.expandedClass);\n                    }\n                }\n\n                // if this item is being moved from the top, add it to the top of the list.\n                if (previousTopOffset && (previousTopOffset <= previousItem.offset().top)) {\n                    previousItem.children(o.listType).prepend(this.placeholder);\n                } else {\n                    // otherwise, add it to the bottom of the list.\n                    previousItem.children(o.listType)[0].appendChild(this.placeholder[0]);\n                }\n                if(typeof parentItem !== 'undefined')\n                    this._clearEmpty(parentItem[0]);\n                this._trigger(\"change\", event, this._uiHash());\n            } else {\n                this._isAllowed(parentItem, level, level + childLevels);\n            }\n\n            //Post events to containers\n            this._contactContainers(event);\n\n            //Interconnect with droppables\n            if ($.ui.ddmanager) {\n                $.ui.ddmanager.drag(this, event);\n            }\n\n            //Call callbacks\n            this._trigger(\"sort\", event, this._uiHash());\n\n            this.lastPositionAbs = this.positionAbs;\n            return false;\n\n        },\n\n        _mouseStop: function(event) {\n            // if the item is in a position not allowed, send it back\n            if (this.beyondMaxLevels) {\n\n                this.placeholder.removeClass(this.options.errorClass);\n\n                if (this.domPosition.prev) {\n                    $(this.domPosition.prev).after(this.placeholder);\n                } else {\n                    $(this.domPosition.parent).prepend(this.placeholder);\n                }\n\n                this._trigger(\"revert\", event, this._uiHash());\n\n            }\n\n            // clear the hovering timeout, just to be sure\n            $(\".\" + this.options.hoveringClass)\n                .mouseleave()\n                .removeClass(this.options.hoveringClass);\n\n            this.mouseentered = false;\n            if (this.hovering) {\n                window.clearTimeout(this.hovering);\n            }\n            this.hovering = null;\n\n            this._relocate_event = event;\n            this._pid_current = $(this.domPosition.parent).parent().attr(\"id\");\n            this._sort_current = this.domPosition.prev ? $(this.domPosition.prev).next().index() : 0;\n            $.ui.sortable.prototype._mouseStop.apply(this, arguments); //asynchronous execution, @see _clear for the relocate event.\n        },\n\n        // this function is slightly modified\n        // to make it easier to hover over a collapsed element and have it expand\n        _intersectsWithSides: function(item) {\n            var half = this.options.isTree ? 0.8 : 0.5,\n                isOverBottomHalf = isOverAxis(\n                    this.positionAbs.top + this.offset.click.top,\n                    item.top + (item.height * half),\n                    item.height\n                ),\n                isOverTopHalf = isOverAxis(\n                    this.positionAbs.top + this.offset.click.top,\n                    item.top - (item.height * half),\n                    item.height\n                ),\n                isOverRightHalf = isOverAxis(\n                    this.positionAbs.left + this.offset.click.left,\n                    item.left + (item.width / 2),\n                    item.width\n                ),\n                verticalDirection = this._getDragVerticalDirection(),\n                horizontalDirection = this._getDragHorizontalDirection();\n\n            if (this.floating && horizontalDirection) {\n                return (\n                    (horizontalDirection === \"right\" && isOverRightHalf) ||\n                    (horizontalDirection === \"left\" && !isOverRightHalf)\n                );\n            } else {\n                return verticalDirection && (\n                    (verticalDirection === \"down\" && isOverBottomHalf) ||\n                    (verticalDirection === \"up\" && isOverTopHalf)\n                );\n            }\n        },\n\n        _contactContainers: function() {\n            if (this.options.protectRoot && this.currentItem[0].parentNode === this.element[0] ) {\n                return;\n            }\n\n            $.ui.sortable.prototype._contactContainers.apply(this, arguments);\n        },\n\n        _clear: function() {\n            var i;\n            var item;\n\n            $.ui.sortable.prototype._clear.apply(this, arguments);\n\n            //relocate event\n            if (!(this._pid_current === this._uiHash().item.parent().parent().attr(\"id\") &&\n                this._sort_current === this._uiHash().item.index())) {\n                this._trigger(\"relocate\", this._relocate_event, this._uiHash());\n            }\n\n            // clean last empty ul/ol\n            for (i = this.items.length - 1; i >= 0; i--) {\n                item = this.items[i].item[0];\n                this._clearEmpty(item);\n            }\n        },\n\n        toArray: function(options) {\n\n            var o = $.extend({}, this.options, options);\n            var sDepth = o.startDepthCount || 0;\n            var ret = [];\n            var left = 1;\n\n            if (!o.excludeRoot) {\n                var rootNode = {\n                    item_id: o.rootID,\n                    parent_id: null,\n                    depth: sDepth\n                };\n                rootNode[o.left] = left;\n                rootNode[o.right] = ($(o.items, this.element).length + 1) * 2;\n                ret.push(rootNode);\n                left++;\n            }\n\n            $(this.element).children(o.items).each(function() {\n                left = _recursiveArray(this, sDepth, left);\n            });\n\n            ret = ret.sort(function(a, b) { return (a.left - b.left); });\n\n            return ret;\n\n            function _recursiveArray(item, depth, _left) {\n\n                var right = _left + 1;\n                var id;\n                var pid;\n                var parentItem;\n\n                if ($(item).children(o.listType).children(o.items).length > 0) {\n                    depth++;\n                    $(item).children(o.listType).children(o.items).each(function() {\n                        right = _recursiveArray($(this), depth, right);\n                    });\n                    depth--;\n                }\n\n                id = $(item).data(o.attribute);\n\n                if (depth === sDepth) {\n                    pid = o.rootID;\n                } else {\n                    parentItem = ($(item).parent(o.listType)\n                        .parent(o.items)\n                        .data(o.attribute));\n                    pid = parentItem;\n                }\n\n                if (id) {\n                    var data = $(item).children('div').data();\n                    var itemObj = $.extend(data, {\n                        id:id,\n                        parent_id:pid,\n                        depth:depth,\n                    });\n                    itemObj[o.left] = _left;\n                    itemObj[o.right] = right;\n\n                    ret.push( itemObj );\n                }\n\n                _left = right + 1;\n                return _left;\n            }\n        },\n\n        _clearEmpty: function (item) {\n            function replaceClass(elem, search, replace, swap) {\n                if (swap) {\n                    search = [replace, replace = search][0];\n                }\n\n                $(elem).removeClass(search).addClass(replace);\n            }\n\n            var o = this.options;\n            var childrenList = $(item).children(o.listType);\n            var hasChildren = childrenList.has('li').length;\n\n            var doNotClear =\n                o.doNotClear ||\n                hasChildren ||\n                o.protectRoot && $(item)[0] === this.element[0];\n\n            if (o.isTree) {\n                replaceClass(item, o.branchClass, o.leafClass, doNotClear);\n            }\n\n            if (!doNotClear) {\n                childrenList.parent().removeClass(o.expandedClass);\n                childrenList.remove();\n            }\n        },\n\n        _getLevel: function(item) {\n            var level = 1;\n            var list;\n\n            if (this.options.listType) {\n                list = item.closest(this.options.listType);\n                while (list && list.length > 0 && !list.is(\".ui-sortable\")) {\n                    level++;\n                    list = list.parent().closest(this.options.listType);\n                }\n            }\n\n            return level;\n        },\n\n        _getChildLevels: function(parent, depth) {\n            var self = this;\n            var o = this.options;\n            var result = 0;\n            depth = depth || 0;\n\n            $(parent).children(o.listType).children(o.items).each(function(index, child) {\n                result = Math.max(self._getChildLevels(child, depth + 1), result);\n            });\n\n            return depth ? result + 1 : result;\n        },\n\n        _isAllowed: function(parentItem, level, levels) {\n            var o = this.options,\n                // this takes into account the maxLevels set to the recipient list\n                maxLevels = this\n                    .placeholder\n                    .closest(\".ui-sortable\")\n                    .nestedSortable(\"option\", \"maxLevels\"),\n\n                // Check if the parent has changed to prevent it, when o.disableParentChange is true\n                oldParent = this.currentItem.parent().parent(),\n                disabledByParentchange = o.disableParentChange && (\n                    //From somewhere to somewhere else, except the root\n                    typeof parentItem !== 'undefined' && !oldParent.is(parentItem) ||\n                    typeof parentItem === 'undefined' && oldParent.is(\"li\") //From somewhere to the root\n                );\n            // is the root protected?\n            // are we nesting too deep?\n            if (\n                disabledByParentchange ||\n                !o.isAllowed(this.placeholder, parentItem, this.currentItem)\n            ) {\n                this.placeholder.addClass(o.errorClass);\n                if (maxLevels < levels && maxLevels !== 0) {\n                    this.beyondMaxLevels = levels - maxLevels;\n                } else {\n                    this.beyondMaxLevels = 1;\n                }\n            } else {\n                if (maxLevels < levels && maxLevels !== 0) {\n                    this.placeholder.addClass(o.errorClass);\n                    this.beyondMaxLevels = levels - maxLevels;\n                } else {\n                    this.placeholder.removeClass(o.errorClass);\n                    this.beyondMaxLevels = 0;\n                }\n            }\n        }\n    }));\n\n    $.qccf.nestedSortable.prototype.options = $.extend(\n        {},\n        $.ui.sortable.prototype.options,\n        $.qccf.nestedSortable.prototype.options\n    );\n}));\n"]}